---
layout: post
title: MalwareTech Beginner Malware Reversing Challenges shellcode1 Writeup
---

## Environment
* Host OS: Kali linux 2018.4
* Guest OS: Windows 7 Home Basic
* Virtualization: Virtualbox 5.2.22 
* Debugger: IDA Pro 7.0
* Other: Resource Hacker v5.1.7

## Explanation
We have several malware reversing challenges <a href="https://www.malwaretech.com/beginner-malware-reversing-challenges">this page</a> on MalwareTech<br>
This is a write-up of "shellcode1".
{% highlight shell %}
shellcode1.exe contains a flag stored within the executable. When run, the program will output an MD5 hash of the flag but not the original. Can you extract the flag?
{% endhighlight %}

## Solution
### 1. Opening the shellcode1.exe
Let's open the shellcode1.exe.<br>
As we can see on a following picture, it shows a MD5 encrypted flag.

![placeholder](https://inar1.github.io/public/images/2019-02-14-09-19-04.png)

Just like strings challenges, we have to "decrypt" this MD5 hash and get original text.

### 2. Analyzing assembly code
Same as last challenge, to encrypt the original text, a function MD5:digestString is used.

![placeholder](https://inar1.github.io/public/images/2019-02-16-13-18-10.png)

It's argument is in an offset "Str" and it must be a text which we're looking for.<br>
However, it is already encrypted and sounds like does not mean anything.

![placeholder](https://inar1.github.io/public/images/2019-02-16-13-20-55.png)

In this assembly code, we can find the "offset Str" one more time.

![placeholder](https://inar1.github.io/public/images/2019-02-16-18-00-21.png)

As we can see, it's getting the length of Str and storing it into [ecx+4].<br>
Then, figure out what it ecx.

![placeholder](https://inar1.github.io/public/images/2019-02-16-14-16-54.png)

Sounds like the value of ecx is return value of HeapAlloc.

{% highlight c %}
DECLSPEC_ALLOCATOR LPVOID HeapAlloc(
  HANDLE hHeap,  // A handle to the heap from which the memory will be allocated. This handle is returned by the HeapCreate or GetProcessHeap function.
  DWORD  dwFlags,  // The heap allocation options.
  SIZE_T dwBytes  // The number of bytes to be allocated.
);
{% endhighlight %}
And the return value is a pointer to the allocated momory block.<br>
This means, after these instructions below, values of ecx and ecx+4 are
{% highlight shell %}
ecx: pointer to allocated heap
ecx+4: length of Str
{% endhighlight %}

Then we still have 3 functions which we have to analyze.<br>
{% highlight shell %}
call    ds:VirtualAlloc
call    memcpy
call    [ebp+Dst]
{% endhighlight %}
Sounds like return value of VirtualAlloc is set in [ebp+Dst].
![placeholder](https://inar1.github.io/public/images/2019-02-16-17-49-29.png)
According to the <a href="">official document</a>, the arguments of VirtualAlloc are
{% highlight c %}
LPVOID VirtualAlloc(
  LPVOID lpAddress,        // The starting address of the region to allocate. 
  SIZE_T dwSize,           // The size of the region, in bytes.
  DWORD flAllocationType,  // The type of memory allocation.
  DWORD flProtect          // The memory protection for the region of pages to be allocated.
);
{% endhighlight %}
and in this case, VirtualAlloc is called like
{% highlight c %}
LPVOID WINAPI VirtualAlloc(0, 0Dh, 1000h, 40h);
{% endhighlight %}

Next, look at <a href="http://www.cplusplus.com/reference/cstring/memcpy/">memcpy</a>.

{% highlight c %}
void *  memcpy(
  void * destination,   // Pointer to the destination array where the content is to be copied, type-casted to a pointer of type void*.
  const void * source,  // Pointer to the source of data to be copied, type-casted to a pointer of type const void*.
  size_t num,           // Number of bytes to copy.
);
{% endhiglight %}

This means, in this case, memcpy is called like
{% highlight c %}
memcpy([ebp+Dst], offset unk_404068, 0Dh)
{% endhighlight %}

We can find that the unknown function [ebp+Dst] is from offset unk_404068.
Looks like just some encrypted codes. However, we can convert the data to code with C key.

![placeholder](https://inar1.github.io/public/images/2019-02-16-15-13-14.png)

Sounds like this doing followning things.
{% highlight shell %}
1. put value of [esi] into edi
2. put value of [esi+4] into ecx
3. Rotate left the values of esi 5 times
4. Do this procedure for esi length + 4 times
{% endhighlight %}
At this time, the value of esi is [ebp+var_4]. This means it is heap space allocated.<br>
Now, we have offset Str in the heapspace.<br>
In summerize, the value which Str is modified by this function above is the original text.

### 3. decryption
Now we know what we have to do.<br>
After selecting the data we need, we can export it with "Edit->Export data" (or Shift+E) and choose C hex for python code.
![placeholder](https://inar1.github.io/public/images/2019-02-16-16-08-45.png)

Then, what we have to do is writing a code for decryption.<br>
{% highlight python %}
#! /usr/bin/python


flag = bytearray([0x32, 0x62, 0x0A, 0x3A, 0xDB, 0x9A, 0x42, 0x2A, 0x62, 0x62,
                  0x1A, 0x7A, 0x22, 0x2A, 0x69, 0x4A, 0x9A, 0x72, 0xA2, 0x69,
                  0x52, 0xAA, 0x9A, 0xA2, 0x69, 0x32, 0x7A, 0x92, 0x69, 0x2A,
                  0xC2, 0x82, 0x62, 0x7A, 0x4A, 0xA2, 0x9A, 0xEB, 0x00, 0x00])


rol = lambda val, r_bits, max_bits: \
(val << r_bits%max_bits) & (2**max_bits-1) | \
((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))

for i in range(len(flag)):
    flag[i] = rol(flag[i], 5, 8)

print flag
{% endhiglight %}
By executing this code, we can obtain the original text.

{% highlight shell %}
root@kali:~# ./rol.py 
FLAG{SHELLCODE-ISNT-JUST-FOR-EXPLOITS}
{% endhighlight %}
